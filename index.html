<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ç„¡é™æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ»ã‚¸ãƒ£ãƒ³ãƒ—ã‚²ãƒ¼ãƒ </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;          /* ç”»é¢ã®ç¸¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²ã */
      background: #87ceeb;       /* ç©ºã®è‰² */
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      touch-action: none;        /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¸ã‚§ã‚¹ãƒãƒ£ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ« */
      -webkit-user-select: none;
      user-select: none;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    canvas {
      display: block;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <script>
    // ==========================
    // åŸºæœ¬è¨­å®šãƒ»ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
    // ==========================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let player;
    let playerBaseX = 0;          // é€šå¸¸ã®åŸºæº–ä½ç½®X

    let walls = [];       // å£ï¼ˆè¶³å ´ã€æŠ¼ã—æˆ»ã—ï¼‰
    let platforms = [];   // ç©ºä¸­åºŠ
    let items = [];       // ã‚¢ã‚¤ãƒ†ãƒ ï¼šã‚¹ã‚³ã‚¢ãƒ»ã²ã‚ˆã“ãƒ»è‡ªè»¢è»Š
    let birds = [];       // ç©ºã®æ•µï¼ˆé³¥ãƒ»çˆ†å¼¾ãƒ»å”è¾›å­ï¼‰
    let turtles = [];     // åœ°ä¸Šã®æ•µï¼ˆäº€ï¼‰
    let mushrooms = [];   // åœ°ä¸Šã®æ•µï¼ˆã‚­ãƒã‚³ï¼‰
    let holes = [];       // ç©´ï¼ˆä»Šã¯å‡ºã•ãªã„ï¼‰
    let floatTexts = [];  // ã‚¢ã‚¤ãƒ†ãƒ å–å¾—æ™‚ã®ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆ

    let score = 0;
    let gameOver = false;
    let isTouching = false;
    let prevIsTouching = false;

    let lastTime = 0;

    const BASE_SCROLL_SPEED = 240;  // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åŸºæœ¬é€Ÿåº¦ï¼ˆpx/secï¼‰
    const GRAVITY = 900;            // é‡åŠ›åŠ é€Ÿåº¦
    const GROUND_RATIO = 0.8;       // åœ°é¢ã®é«˜ã•ï¼ˆç”»é¢é«˜ã•ã«å¯¾ã™ã‚‹æ¯”ç‡ï¼‰
    const TOP_LIMIT = 20;           // ä¸Šæ–¹å‘ã®åˆ¶é™ä½ç½®

    let spawnTimer = 0;
    let nextSpawnTime = 1.0;

    // --- ãƒ¢ãƒ¼ãƒ‰ç®¡ç† ---
    let isChickMode = false;
    let chickTimer = 0;
    const CHICK_MODE_DURATION = 4.0;

    let isBikeMode = false;
    let bikeTimer = 0;
    const BIKE_MODE_DURATION = CHICK_MODE_DURATION * 3;

    // --- ãƒ©ã‚¤ãƒ•ç®¡ç† ---
    let lives = 3;
    let invincibleTimer = 0;
    const INVINCIBLE_TIME = 0.8;

    // --- ã‚¸ãƒ£ãƒ³ãƒ—ç®¡ç† ---
    let jumpUsesLeft = 2;              // æ®‹ã‚Šã‚¸ãƒ£ãƒ³ãƒ—ãƒ›ãƒ¼ãƒ«ãƒ‰å›æ•°ï¼ˆæœ€å¤§2ï¼‰
    let isCurrentlyThrusting = false;  // ä»Šã®ãƒ›ãƒ¼ãƒ«ãƒ‰ã§ä¸Šæ˜‡ä¸­ã‹

    // --- ã‚¹ãƒ¯ã‚¤ãƒ—åˆ¤å®š ---
    let touchStartY = null;

    // --- ãƒ­ã‚¹ãƒˆè¡¨ç¤ºï¼†ä¸€æ™‚åœæ­¢ ---
    let lostMessageTimer = 0;      // LOST! è¡¨ç¤ºç”¨
    let isRespawnPause = false;    // ãƒ­ã‚¹ãƒˆæ¼”å‡ºä¸­ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åœæ­¢ï¼‰
    let respawnPauseTimer = 0;     // ä¸€æ™‚åœæ­¢æ™‚é–“

    // ==========================
    // ã‚µã‚¦ãƒ³ãƒ‰ï¼ˆBGM + ã‚¤ãƒ™ãƒ³ãƒˆéŸ³ï¼‰
    // ==========================
    let audioCtx = null;
    let bgmOsc1 = null;
    let bgmOsc2 = null;
    let bgmGain = null;

    function initAudio() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          audioCtx = new AC();
        }
      }
    }

    function resumeAudio() {
      if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume();
      }
    }

    // å…¨ä½“BGMï¼šå°ã•ã„2éŸ³ãƒ«ãƒ¼ãƒ—
    function startBGM() {
      if (!audioCtx || bgmOsc1) return;

      bgmOsc1 = audioCtx.createOscillator();
      bgmOsc2 = audioCtx.createOscillator();
      bgmGain = audioCtx.createGain();

      bgmOsc1.type = "triangle";
      bgmOsc2.type = "square";
      bgmOsc1.frequency.value = 220; // A3
      bgmOsc2.frequency.value = 330; // E4

      bgmGain.gain.value = 0.04;

      bgmOsc1.connect(bgmGain);
      bgmOsc2.connect(bgmGain);
      bgmGain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      bgmGain.gain.setValueAtTime(0.03, now);
      bgmGain.gain.linearRampToValueAtTime(0.05, now + 2);
      bgmGain.gain.linearRampToValueAtTime(0.03, now + 4);

      bgmOsc1.start();
      bgmOsc2.start();
    }

    function stopBGM() {
      if (bgmOsc1) {
        try { bgmOsc1.stop(); } catch(e){}
        try { bgmOsc2.stop(); } catch(e){}
      }
      bgmOsc1 = null;
      bgmOsc2 = null;
      bgmGain = null;
    }

    // æ±ç”¨ãƒ“ãƒ¼ãƒ—
    function playBeep(f, duration, type = "sine", volume = 0.3) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = f;
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(volume, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

      osc.start(now);
      osc.stop(now + duration + 0.05);
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆåˆ¥ã‚µã‚¦ãƒ³ãƒ‰
    function playScoreItemSound() {        // é£Ÿã¹ç‰©ã‚¢ã‚¤ãƒ†ãƒ 
      playBeep(880, 0.10, "sine", 0.25);
      setTimeout(() => playBeep(1320, 0.10, "sine", 0.2), 90);
    }

    function playChickSound() {            // ã²ã‚ˆã“ã‚¢ã‚¤ãƒ†ãƒ 
      playBeep(660, 0.12, "triangle", 0.3);
      setTimeout(() => playBeep(990, 0.12, "triangle", 0.25), 120);
    }

    function playBikeSound() {             // è‡ªè»¢è»Šã‚¢ã‚¤ãƒ†ãƒ 
      playBeep(440, 0.10, "square", 0.3);
      setTimeout(() => playBeep(660, 0.10, "square", 0.25), 110);
      setTimeout(() => playBeep(880, 0.10, "square", 0.2), 220);
    }

    function playBikeBonusSound() {        // è‡ªè»¢è»Šä¸­ã«è‡ªè»¢è»Šã‚’å–ã£ã¦+20
      playBeep(1200, 0.08, "sawtooth", 0.3);
      setTimeout(() => playBeep(1600, 0.12, "sawtooth", 0.25), 80);
    }

    function playHitSound() {              // ãƒ­ã‚¹ãƒˆæ™‚
      playBeep(220, 0.25, "square", 0.35);
      setTimeout(() => playBeep(180, 0.25, "square", 0.3), 180);
    }

    // ==========================
    // ç”»é¢ã‚µã‚¤ã‚ºãƒ»åœ°é¢ã®é«˜ã•
    // ==========================
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      playerBaseX = canvas.width * 0.15;
    }

    function getGroundY() {
      return canvas.height * GROUND_RATIO;
    }

    // ==========================
    // ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ãƒ»ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
    // ==========================
    function resetGame() {
      const groundY = getGroundY();
      playerBaseX = canvas.width * 0.15;

      player = {
        x: playerBaseX,
        y: groundY - 40,
        width: 40,
        height: 40,
        vy: 0,
        emoji: "ğŸƒâ€â™‚ï¸",
        angle: 0,
        onGround: true
      };

      walls = [];
      platforms = [];
      items = [];
      birds = [];
      turtles = [];
      mushrooms = [];
      holes = [];
      floatTexts = [];

      score = 0;
      gameOver = false;
      spawnTimer = 0;
      nextSpawnTime = randomRange(0.8, 1.6);

      isChickMode = false;
      chickTimer = 0;
      isBikeMode = false;
      bikeTimer = 0;

      lives = 3;
      invincibleTimer = 0;

      jumpUsesLeft = 2;
      isCurrentlyThrusting = false;
      prevIsTouching = false;

      lostMessageTimer = 0;
      isRespawnPause = false;
      respawnPauseTimer = 0;
    }

    // ==========================
    // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    // ==========================
    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y
      );
    }

    function isPlayerOverHole(p) {
      const pxCenter = p.x + p.width / 2;
      for (const hole of holes) {
        if (pxCenter > hole.x && pxCenter < hole.x + hole.width) {
          return true;
        }
      }
      return false;
    }

    // ==========================
    // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
    // ==========================
    function activateChickMode() {
      isChickMode = true;
      chickTimer = CHICK_MODE_DURATION;
      if (isBikeMode) {
        isBikeMode = false;
        bikeTimer = 0;
      }
      player.emoji = "ğŸ¥";
      playChickSound();
    }

    function activateBikeMode() {
      isBikeMode = true;
      bikeTimer = BIKE_MODE_DURATION;
      if (isChickMode) {
        isChickMode = false;
        chickTimer = 0;
      }
      player.emoji = "ğŸš´";
      playBikeSound();
    }

    function updateModeTimers(dt) {
      if (isChickMode) {
        chickTimer -= dt;
        if (chickTimer <= 0) {
          isChickMode = false;
          chickTimer = 0;
          if (!isBikeMode) player.emoji = "ğŸƒâ€â™‚ï¸";
        }
      }
      if (isBikeMode) {
        bikeTimer -= dt;
        if (bikeTimer <= 0) {
          isBikeMode = false;
          bikeTimer = 0;
          if (!isChickMode) player.emoji = "ğŸƒâ€â™‚ï¸";
        }
      }
    }

    function getCurrentScrollSpeed() {
      if (isRespawnPause) return 0; // ãƒ­ã‚¹ãƒˆä¸­ã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åœæ­¢
      let speed = BASE_SCROLL_SPEED;
      if (isChickMode) speed = BASE_SCROLL_SPEED * 0.6;
      if (isBikeMode)  speed = BASE_SCROLL_SPEED * 1.3;
      return speed;
    }

    // ==========================
    // ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
    // ==========================
    function damagePlayer(options = {}) {
      if (invincibleTimer > 0 || gameOver) return;

      lives--;
      playHitSound();
      invincibleTimer = INVINCIBLE_TIME;
      lostMessageTimer = 1.0; // LOST! è¡¨ç¤º

      if (lives <= 0) {
        gameOver = true;
        stopBGM();
        return;
      }

      // respawnFromTop ã®ã¨ãï¼šã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä¸€æ™‚åœæ­¢ & ä¸Šã‹ã‚‰æ–°ã—ã„è‡ªåˆ†
      if (options.respawnFromTop) {
        const groundY = getGroundY();
        player.x = playerBaseX;
        player.y = -player.height - 10;
        player.vy = 300;
        player.onGround = false;

        // ãƒ¢ãƒ¼ãƒ‰è§£é™¤ã—ã¦äººé–“ã«æˆ»ã™
        isChickMode = false;
        chickTimer = 0;
        isBikeMode = false;
        bikeTimer = 0;
        player.emoji = "ğŸƒâ€â™‚ï¸";

        isRespawnPause = true;
        respawnPauseTimer = 1.2; // åœæ­¢ä¸­ã®æ™‚é–“ï¼ˆç§’ï¼‰
      }
    }

    // ==========================
    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
    // ==========================
    function spawnObject() {
      const groundY = getGroundY();
      const x = canvas.width + 40;
      const r = Math.random();

      // ã‚¢ã‚¤ãƒ†ãƒ å‡ºç¾ç‡ã‚’å…¨ä½“çš„ã«å¢—ã‚„ã™
      if (r < 0.30) {
        // ã‚¹ã‚³ã‚¢ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆé£Ÿã¹ç‰©ï¼‰
        const foodEmojis = ["ğŸ", "ğŸŒ", "ğŸ•", "ğŸ©", "ğŸ”", "ğŸ‡", "ğŸ°", "ğŸ–"];
        items.push({
          type: "score",
          x,
          y: randomRange(groundY * 0.3, groundY - 120),
          width: 28,
          height: 28,
          emoji: foodEmojis[Math.floor(Math.random() * foodEmojis.length)]
        });
      } else if (r < 0.42) {
        // ã²ã‚ˆã“ã‚¢ã‚¤ãƒ†ãƒ 
        items.push({
          type: "chick",
          x,
          y: randomRange(groundY * 0.3, groundY - 140),
          width: 30,
          height: 30,
          emoji: "ğŸ£"
        });
      } else if (r < 0.54) {
        // è‡ªè»¢è»Šã‚¢ã‚¤ãƒ†ãƒ 
        items.push({
          type: "bike",
          x,
          y: randomRange(groundY * 0.3, groundY - 140),
          width: 34,
          height: 34,
          emoji: "ğŸš²"
        });
      } else if (r < 0.66) {
        // é€šå¸¸ã®å£
        const wallHeight = randomRange(50, 140);
        walls.push({
          x,
          y: groundY - wallHeight,
          width: 40,
          height: wallHeight
        });
      } else if (r < 0.76) {
        // éšæ®µçŠ¶ã®å£
        const stepCount = Math.random() < 0.5 ? 2 : 3;
        const stepWidth = 40;
        const stepHeight = 35;
        for (let i = 0; i < stepCount; i++) {
          const h = stepHeight * (i + 1);
          walls.push({
            x: x + i * stepWidth,
            y: groundY - h,
            width: stepWidth,
            height: h
          });
        }
      } else if (r < 0.84) {
        // äº€
        const h = 32;
        turtles.push({
          x,
          y: groundY - h,
          width: 40,
          height: h,
          emoji: "ğŸ¢"
        });
      } else if (r < 0.92) {
        // ã‚­ãƒã‚³
        const h = 32;
        mushrooms.push({
          x,
          y: groundY - h,
          width: 32,
          height: h,
          emoji: "ğŸ„"
        });
      } else if (r < 0.985) {
        // ç©ºã®æ•µï¼šé³¥ï¼‹çˆ†å¼¾ï¼‹å”è¾›å­
        const h = 32;
        const airEmojis = ["ğŸ¦", "ğŸ’£", "ğŸŒ¶ï¸"];
        birds.push({
          x,
          y: randomRange(80, groundY - 130),
          width: 40,
          height: h,
          emoji: airEmojis[Math.floor(Math.random() * airEmojis.length)]
        });
      } else {
        // ç©ºä¸­åºŠ
        const platWidth = randomRange(100, 160);
        const platY = randomRange(groundY * 0.4, groundY * 0.7);
        platforms.push({
          x,
          y: platY,
          width: platWidth,
          height: 20
        });
      }
    }

    // ==========================
    // å…¥åŠ›å‡¦ç†ï¼ˆã‚¿ãƒƒãƒ—ãƒ»ã‚¹ãƒ¯ã‚¤ãƒ—ï¼‰
    // ==========================
    function handleTouchStart(e) {
      e.preventDefault();

      if (!audioCtx) {
        initAudio();
      } else {
        resumeAudio();
      }
      startBGM();

      if (gameOver) {
        resetGame();
      }
      isTouching = true;

      const t = e.touches[0];
      touchStartY = t.clientY;
    }

    function handleTouchEnd(e) {
      e.preventDefault();
      isTouching = false;
      touchStartY = null;
    }

    function handleTouchMove(e) {
      e.preventDefault();
      if (e.touches.length === 0) return;
      const t = e.touches[0];
      if (touchStartY === null) touchStartY = t.clientY;
      const dy = t.clientY - touchStartY;

      // ä¸‹ã«ã‚¹ãƒ¯ã‚¤ãƒ— â†’ é«˜é€Ÿè½ä¸‹
      if (dy > 40 && !player.onGround && !gameOver) {
        isTouching = false;
        isCurrentlyThrusting = false;
        jumpUsesLeft = 0;
        if (player.vy < 900) {
          player.vy = 900;
        }
      }
    }

    function setupInput() {
      canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
      canvas.addEventListener("touchend", handleTouchEnd, { passive: false });
      canvas.addEventListener("touchmove", handleTouchMove, { passive: false });

      document.addEventListener("touchmove", function (e) {
        e.preventDefault();
      }, { passive: false });

      // PCãƒ†ã‚¹ãƒˆç”¨
      canvas.addEventListener("mousedown", (e) => {
        e.preventDefault();
        if (!audioCtx) {
          initAudio();
        } else {
          resumeAudio();
        }
        startBGM();
        if (gameOver) {
          resetGame();
        }
        isTouching = true;
      });
      canvas.addEventListener("mouseup", (e) => {
        e.preventDefault();
        isTouching = false;
      });
      canvas.addEventListener("mouseleave", () => {
        isTouching = false;
      });
    }

    // ==========================
    // ã‚²ãƒ¼ãƒ æ›´æ–°å‡¦ç†
    // ==========================
    function update(dt) {
      if (gameOver) return;

      const groundY = getGroundY();

      // ç„¡æ•µãƒ»ãƒ­ã‚¹ãƒˆè¡¨ç¤ºãƒ»ãƒªã‚¹ãƒãƒ¼ãƒ³ä¸€æ™‚åœæ­¢ã‚¿ã‚¤ãƒãƒ¼
      if (invincibleTimer > 0) {
        invincibleTimer -= dt;
        if (invincibleTimer < 0) invincibleTimer = 0;
      }
      if (lostMessageTimer > 0) {
        lostMessageTimer -= dt;
        if (lostMessageTimer < 0) lostMessageTimer = 0;
      }
      if (isRespawnPause) {
        respawnPauseTimer -= dt;
        if (respawnPauseTimer < 0) respawnPauseTimer = 0;
      }

      // ãƒ¢ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒãƒ¼
      updateModeTimers(dt);

      const scrollSpeed = getCurrentScrollSpeed();
      const scroll = scrollSpeed * dt;

      // --- ã‚¿ãƒƒãƒ—é–‹å§‹/çµ‚äº†ã§ã‚¸ãƒ£ãƒ³ãƒ—å›æ•°ç®¡ç† ---
      if (!isTouching && prevIsTouching) {
        if (isCurrentlyThrusting) {
          jumpUsesLeft = Math.max(0, jumpUsesLeft - 1);
          isCurrentlyThrusting = false;
        }
      }

      if (isTouching && !gameOver && !isRespawnPause) {
        if (!isCurrentlyThrusting && jumpUsesLeft > 0) {
          isCurrentlyThrusting = true;
        }
      }

      if (isCurrentlyThrusting) {
        player.vy = -300;
      } else {
        player.vy += GRAVITY * dt;
      }

      const prevY = player.y;
      player.y += player.vy * dt;

      // ä¸Šé™ï¼†å¼·åˆ¶è½ä¸‹é–‹å§‹
      if (player.y < TOP_LIMIT) {
        player.y = TOP_LIMIT;
        if (player.vy < 0) player.vy = 0;
        if (isCurrentlyThrusting) {
          isCurrentlyThrusting = false;
          jumpUsesLeft = Math.max(0, jumpUsesLeft - 1);
        }
      }

      let playerBottom = player.y + player.height;
      let playerTop = player.y;

      // --- è¶³å ´ï¼ˆå£ï¼‹ç©ºä¸­åºŠï¼‰ï¼šç¸¦æ–¹å‘ã®è¡çª ---
      const solids = platforms.concat(walls);
      let onPlatform = false;

      for (const solid of solids) {
        const overlapX =
          player.x + player.width > solid.x &&
          player.x < solid.x + solid.width;
        if (!overlapX) continue;

        // ä¸Šã‹ã‚‰ç€åœ°
        if (
          player.vy >= 0 &&
          playerBottom >= solid.y &&
          playerBottom <= solid.y + solid.height
        ) {
          player.y = solid.y - player.height;
          player.vy = 0;
          playerBottom = player.y + player.height;
          playerTop = player.y;
          onPlatform = true;
          break;
        }

        // ä¸‹ã‹ã‚‰ã¶ã¤ã‹ã£ãŸã‚‰ä¸Šã«æŠœã‘ãªã„
        if (
          player.vy < 0 &&
          playerTop <= solid.y + solid.height &&
          prevY >= solid.y + solid.height
        ) {
          player.y = solid.y + solid.height;
          player.vy = 0;
          playerTop = player.y;
          playerBottom = player.y + player.height;
          break;
        }
      }

      // --- åœ°é¢ãƒ»ç©´å‡¦ç† ---
      let onGroundNow = false;
      if (!onPlatform && player.vy >= 0 && playerBottom >= groundY) {
        if (isPlayerOverHole(player) && invincibleTimer <= 0) {
          damagePlayer({ respawnFromTop: true });
        }
        player.y = groundY - player.height;
        player.vy = 0;
        playerBottom = player.y + player.height;
        playerTop = player.y;
        onGroundNow = true;
      }

      player.onGround = onGroundNow || onPlatform;

      // ç”»é¢ä¸‹è½ä¸‹ â†’ ãƒ­ã‚¹ãƒˆï¼‹ä¸Šã‹ã‚‰
      if (player.y > canvas.height && invincibleTimer <= 0) {
        damagePlayer({ respawnFromTop: true });
      }

      // è¶³å ´ã«ç«‹ã£ã¦ã„ã‚‹ã¨ãã¯ã‚¸ãƒ£ãƒ³ãƒ—å›æ•°ãƒªã‚»ãƒƒãƒˆ
      if (player.onGround && player.vy === 0) {
        jumpUsesLeft = 2;
        if (!isTouching) {
          isCurrentlyThrusting = false;
        }
      }

      // --- èƒŒæ™¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç§»å‹•ï¼ˆãƒ­ã‚¹ãƒˆä¸­ã‚‚ä½ç½®ã¯ç¶­æŒï¼‰ ---
      function moveAndFilter(list) {
        return list
          .map(obj => {
            obj.x -= scroll;
            return obj;
          })
          .filter(obj => obj.x + (obj.width || 0) > -50);
      }

      walls = moveAndFilter(walls);
      platforms = moveAndFilter(platforms);
      items = moveAndFilter(items);
      birds = moveAndFilter(birds);
      turtles = moveAndFilter(turtles);
      mushrooms = moveAndFilter(mushrooms);

      holes = holes
        .map(hole => {
          hole.x -= scroll;
          return hole;
        })
        .filter(hole => hole.x + hole.width > -50);

      // --- å£ã®æ¨ªè¡çªï¼šæŠ¼ã—æˆ»ã•ã‚Œã‚‹å‡¦ç† ---
      let playerRect = {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      };

      let pushedByWall = false;

      for (const wall of walls) {
        const wallRect = {
          x: wall.x,
          y: wall.y,
          width: wall.width,
          height: wall.height
        };
        if (rectsOverlap(playerRect, wallRect)) {
          // å£ã®å·¦å´ã¾ã§æŠ¼ã—ä»˜ã‘ã‚‹
          player.x = wall.x - player.width;
          playerRect.x = player.x;
          pushedByWall = true;
        }
      }

      // å£ã«æŠ¼ã•ã‚Œã¦å·¦ç”»é¢å¤– â†’ ãƒ­ã‚¹ãƒˆï¼‹ä¸Šã‹ã‚‰æ–°ã—ã„è‡ªåˆ†
      if (player.x + player.width < 0 && invincibleTimer <= 0) {
        damagePlayer({ respawnFromTop: true });
        playerRect.x = player.x;
        playerRect.y = player.y;
      }

      // å£ã‹ã‚‰æŠœã‘ã¦å·¦ã«å¯„ã£ã¦ã„ã‚‹ã¨ã â†’ è‡ªå‹•ã§åŸºæº–ä½ç½®ã«æˆ»ã‚‹
      if (!pushedByWall && player.x < playerBaseX && !isRespawnPause) {
        const returnSpeed = 300;
        player.x += returnSpeed * dt;
        if (player.x > playerBaseX) player.x = playerBaseX;
        playerRect.x = player.x;
      }

      // --- æ•µã¨ã®å½“ãŸã‚Šåˆ¤å®š ---
      function handleEnemyHit() {
        if (isBikeMode) {
          // è‡ªè»¢è»Šä¸­ã¯ãƒ­ã‚¹ãƒˆã›ãšã€äººé–“ã«æˆ»ã‚‹ã ã‘
          isBikeMode = false;
          bikeTimer = 0;
          if (!isChickMode) player.emoji = "ğŸƒâ€â™‚ï¸";
        } else if (invincibleTimer <= 0) {
          damagePlayer({ respawnFromTop: true });
        }
      }

      for (const t of turtles) {
        if (rectsOverlap(playerRect, t)) {
          handleEnemyHit();
          break;
        }
      }
      if (!gameOver) {
        for (const m of mushrooms) {
          if (rectsOverlap(playerRect, m)) {
            handleEnemyHit();
            break;
          }
        }
      }
      if (!gameOver) {
        for (const b of birds) {
          if (rectsOverlap(playerRect, b)) {
            handleEnemyHit();
            break;
          }
        }
      }

      // --- ã‚¢ã‚¤ãƒ†ãƒ å–å¾— ---
      if (!gameOver) {
        items = items.filter(item => {
          if (rectsOverlap(playerRect, item)) {
            let text = "";
            if (item.type === "score") {
              score += 10;
              playScoreItemSound();
              text = "+10";
            } else if (item.type === "chick") {
              activateChickMode();
              text = "ğŸ¥";
            } else if (item.type === "bike") {
              const wasBike = isBikeMode;
              if (wasBike) {
                score += 20;
                playBikeBonusSound();
                text = "+20";
              } else {
                text = "ğŸš´";
              }
              activateBikeMode();
            }
            floatTexts.push({
              x: item.x + item.width / 2,
              y: item.y,
              text,
              life: 0.8
            });
            return false;
          }
          return true;
        });
      }

      // ã‚¹ã‚³ã‚¢ï¼ˆç”Ÿå­˜æ™‚é–“ï¼‰â€»ãƒ­ã‚¹ãƒˆæ¼”å‡ºä¸­ã¯å¢—ã‚„ã•ãªã„
      if (!gameOver && !isRespawnPause) {
        score += dt * 5;
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢ï¼ˆå¸¸ã«å‰è»¢ï¼‰
      const inNormalMode = !isBikeMode && !isChickMode;
      let rollDir = 1;
      if (isBikeMode || inNormalMode) {
        // å·¦å³åè»¢æç”»ãªã®ã§è¦‹ãŸç›®å‰è»¢ã«ãªã‚‹ã‚ˆã†ã«ç¬¦å·åè»¢
        rollDir = -1;
      }
      const ROLL_SPEED = 4.0;
      player.angle += rollDir * ROLL_SPEED * dt;

      // ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
      floatTexts = floatTexts.filter(ft => {
        ft.y -= 40 * dt;
        ft.life -= dt;
        return ft.life > 0;
      });

      // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆï¼ˆãƒ­ã‚¹ãƒˆä¸€æ™‚åœæ­¢ä¸­ã¯é€²ã‚ãªã„ï¼‰
      if (!isRespawnPause) {
        spawnTimer += dt;
        if (spawnTimer >= nextSpawnTime) {
          spawnObject();
          spawnTimer = 0;
          nextSpawnTime = randomRange(0.8, 1.6);
        }
      }

      // ãƒªã‚¹ãƒãƒ¼ãƒ³ä¸€æ™‚åœæ­¢è§£é™¤æ¡ä»¶ï¼š
      // ãƒ»ã‚¿ã‚¤ãƒãƒ¼ãŒåˆ‡ã‚Œã¦ã„ã‚‹
      // ãƒ»ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒåœ°é¢ã«ç€åœ°ã—ã¦ã„ã‚‹
      if (isRespawnPause && respawnPauseTimer <= 0 && player.onGround) {
        isRespawnPause = false;
      }

      prevIsTouching = isTouching;
    }

    // ==========================
    // æç”»å‡¦ç†
    // ==========================
    function draw() {
      const groundY = getGroundY();

      // èƒŒæ™¯
      ctx.fillStyle = "#87ceeb";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // åœ°é¢
      ctx.fillStyle = "#3c7c1b";
      ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

      // ç©´
      ctx.fillStyle = "#87ceeb";
      for (const hole of holes) {
        ctx.fillRect(hole.x, groundY, hole.width, canvas.height - groundY);
      }

      // å£
      ctx.fillStyle = "#8b4513";
      for (const wall of walls) {
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      }

      // ç©ºä¸­åºŠ
      ctx.fillStyle = "#cccccc";
      for (const plat of platforms) {
        ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆå›è»¢ï¼‹å³å‘ãï¼‰
      const cx = player.x + player.width / 2;
      const cy = player.y + player.height / 2;
      ctx.save();
      ctx.translate(cx, cy);

      const inNormalMode = !isBikeMode && !isChickMode;
      if (isBikeMode || inNormalMode) {
        ctx.scale(-1, 1);
      }

      ctx.rotate(player.angle);
      ctx.font = "32px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(player.emoji, 0, 0);
      ctx.restore();

      // æ•µ
      ctx.font = "28px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (const t of turtles) {
        ctx.fillText(t.emoji, t.x + t.width / 2, t.y + t.height / 2);
      }
      for (const m of mushrooms) {
        ctx.fillText(m.emoji, m.x + m.width / 2, m.y + m.height / 2);
      }
      for (const b of birds) {
        ctx.fillText(b.emoji, b.x + b.width / 2, b.y + b.height / 2);
      }

      // ã‚¢ã‚¤ãƒ†ãƒ 
      for (const item of items) {
        ctx.fillText(item.emoji, item.x + item.width / 2, item.y + item.height / 2);
      }

      // ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆ
      for (const ft of floatTexts) {
        const alpha = Math.max(0, ft.life / 0.8);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "#ffff00";
        ctx.font = "18px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.restore();
      }

      // ãƒ©ã‚¤ãƒ•
      ctx.fillStyle = "#ff0000";
      ctx.font = "24px system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("â¤ï¸".repeat(lives), 10, 10);

      // ã‚¹ã‚³ã‚¢
      ctx.fillStyle = "#000000";
      ctx.font = "20px system-ui";
      ctx.textAlign = "right";
      ctx.textBaseline = "top";
      ctx.fillText("Score: " + Math.floor(score), canvas.width - 16, 10);

      // ãƒ­ã‚¹ãƒˆè¡¨ç¤ºï¼ˆGame Over ã¨ã¯åˆ¥ï¼‰
      if (lostMessageTimer > 0 && !gameOver) {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#ff4444";
        ctx.font = "32px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("LOST!", canvas.width / 2, canvas.height / 2);
        ctx.restore();
      }

      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼è¡¨ç¤º
      if (gameOver) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        ctx.font = "36px system-ui";
        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 20);

        ctx.font = "24px system-ui";
        ctx.fillText("Score: " + Math.floor(score), canvas.width / 2, canvas.height / 2 + 20);

        ctx.font = "18px system-ui";
        ctx.fillText("ç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ", canvas.width / 2, canvas.height / 2 + 60);
      }
    }

    // ==========================
    // ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
    // ==========================
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    // ==========================
    // åˆæœŸåŒ–
    // ==========================
    function init() {
      resizeCanvas();
      resetGame();
      setupInput();
      requestAnimationFrame(gameLoop);
    }

    window.addEventListener("resize", () => {
      resizeCanvas();
      resetGame();
    });

    init();
  </script>
</body>
</html>
