<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ç„¡é™æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ»ã‚¸ãƒ£ãƒ³ãƒ—ã‚²ãƒ¼ãƒ </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #87ceeb; /* ç©ºã®è‰² */
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    canvas {
      display: block;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <script>
    // ==========================
    // åŸºæœ¬è¨­å®šãƒ»ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
    // ==========================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let player;
    let playerBaseX = 0;          // é€šå¸¸ã®åŸºæº–ä½ç½®X

    let walls = [];       // å£ï¼ˆè¶³å ´ã€æŠ¼ã—æˆ»ã—ï¼‰
    let platforms = [];   // ç©ºä¸­åºŠ
    let items = [];       // ã‚¢ã‚¤ãƒ†ãƒ ï¼šã‚¹ã‚³ã‚¢ãƒ»ã²ã‚ˆã“ãƒ»è‡ªè»¢è»Šãƒ»ã‚¹ã‚¿ãƒ¼
    let birds = [];       // ç©ºã®æ•µï¼ˆé³¥ãƒ»çˆ†å¼¾ãƒ»å”è¾›å­ï¼‰
    let bees = [];        // ç©ºã®æ•µï¼šèœ‚ï¼ˆã‚µã‚¤ãƒ³ã‚«ãƒ¼ãƒ–ã§ç§»å‹•ï¼‰
    let ghosts = [];      // ç©ºã®æ•µï¼šã‚ªãƒã‚±ï¼ˆé€²ã‚“ã ã‚Šæ­¢ã¾ã£ãŸã‚Šï¼‰
    let turtles = [];     // åœ°ä¸Šã®æ•µï¼ˆäº€ï¼‰
    let mushrooms = [];   // åœ°ä¸Šã®æ•µï¼ˆã‚­ãƒã‚³ï¼‰
    let holes = [];       // ç©´ï¼ˆåœ°é¢ã®åˆ‡ã‚Œç›®ï¼‰
    let floatTexts = [];  // ã‚¢ã‚¤ãƒ†ãƒ å–å¾—ï¼ã‚¹ã‚¿ãƒ¼æ”»æ’ƒæ™‚ã®ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆ

    let score = 0;
    let gameOver = false;
    let isTouching = false;
    let prevIsTouching = false;

    let lastTime = 0;

    const BASE_SCROLL_SPEED = 240;  // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åŸºæœ¬é€Ÿåº¦ï¼ˆpx/secï¼‰
    const GRAVITY = 900;
    const GROUND_RATIO = 0.8;
    const TOP_LIMIT = 20;

    let spawnTimer = 0;
    let nextSpawnTime = 1.0;

    // --- ãƒ¢ãƒ¼ãƒ‰ç®¡ç† ---
    let isChickMode = false;
    let chickTimer = 0;
    const CHICK_MODE_DURATION = 4.0;

    let isBikeMode = false;
    let bikeTimer = 0;
    const BIKE_MODE_DURATION = CHICK_MODE_DURATION * 3;

    // â­ç„¡æ•µãƒ¢ãƒ¼ãƒ‰
    let isStarMode = false;
    let starTimer = 0;
    const STAR_MODE_DURATION = 5.0;

    // --- ãƒ©ã‚¤ãƒ•ç®¡ç† ---
    let lives = 3;
    let invincibleTimer = 0;
    const INVINCIBLE_TIME = 0.8;

    // --- ã‚¸ãƒ£ãƒ³ãƒ—ç®¡ç† ---
    let jumpUsesLeft = 2;
    let isCurrentlyThrusting = false;

    // --- ã‚¹ãƒ¯ã‚¤ãƒ—åˆ¤å®š ---
    let touchStartY = null;

    // --- ãƒ­ã‚¹ãƒˆè¡¨ç¤ºï¼†ä¸€æ™‚åœæ­¢ ---
    let lostMessageTimer = 0;
    let isRespawnPause = false;
    let respawnPauseTimer = 0;

    // --- ç›´å‰ã«ã‚„ã‚‰ã‚ŒãŸä½ç½®ï¼ˆåŒã˜ã®ã«ä½•åº¦ã‚‚å½“ãŸã‚‰ãªã„ç”¨ï¼‰ ---
    let lastDeathAvoidCenterX = null;

    // ==========================
    // ã‚µã‚¦ãƒ³ãƒ‰ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆéŸ³ã®ã¿ï¼šBGMãªã—ï¼‰
    // ==========================
    let audioCtx = null;

    function initAudio() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          audioCtx = new AC();
        }
      }
    }

    function resumeAudio() {
      if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume();
      }
    }

    function playBeep(f, duration, type = "sine", volume = 0.3) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = f;
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(volume, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

      osc.start(now);
      osc.stop(now + duration + 0.05);
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆåˆ¥éŸ³
    function playScoreItemSound() {
      playBeep(880, 0.10, "sine", 0.25);
      setTimeout(() => playBeep(1320, 0.10, "sine", 0.2), 90);
    }
    function playChickSound() {
      playBeep(660, 0.12, "triangle", 0.3);
      setTimeout(() => playBeep(990, 0.12, "triangle", 0.25), 120);
    }
    function playBikeSound() {
      playBeep(440, 0.10, "square", 0.3);
      setTimeout(() => playBeep(660, 0.10, "square", 0.25), 110);
      setTimeout(() => playBeep(880, 0.10, "square", 0.2), 220);
    }
    function playBikeBonusSound() {
      playBeep(1200, 0.08, "sawtooth", 0.3);
      setTimeout(() => playBeep(1600, 0.12, "sawtooth", 0.25), 80);
    }
    function playHitSound() {
      playBeep(220, 0.25, "square", 0.35);
      setTimeout(() => playBeep(180, 0.25, "square", 0.3), 180);
    }
    // â­å–å¾—æ™‚
    function playStarItemSound() {
      playBeep(1000, 0.08, "sawtooth", 0.3);
      setTimeout(() => playBeep(1300, 0.08, "sawtooth", 0.25), 80);
      setTimeout(() => playBeep(1600, 0.10, "sawtooth", 0.2), 160);
    }
    // â­ä¸­ã«æ•µã‚’å€’ã—ãŸæ™‚
    function playStarHitSound() {
      playBeep(1500, 0.06, "square", 0.3);
      setTimeout(() => playBeep(1800, 0.08, "square", 0.25), 60);
    }

    // ==========================
    // ç”»é¢ã‚µã‚¤ã‚ºãƒ»åœ°é¢
    // ==========================
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      playerBaseX = canvas.width * 0.15;
    }

    function getGroundY() {
      return canvas.height * GROUND_RATIO;
    }

    // ==========================
    // åˆæœŸåŒ–ãƒ»ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
    // ==========================
    function resetGame() {
      const groundY = getGroundY();
      playerBaseX = canvas.width * 0.15;

      player = {
        x: playerBaseX,
        y: groundY - 40,
        width: 40,
        height: 40,
        vy: 0,
        emoji: "ğŸƒâ€â™‚ï¸",
        angle: 0,
        onGround: true
      };

      walls = [];
      platforms = [];
      items = [];
      birds = [];
      bees = [];
      ghosts = [];
      turtles = [];
      mushrooms = [];
      holes = [];
      floatTexts = [];

      score = 0;
      gameOver = false;
      spawnTimer = 0;
      nextSpawnTime = randomRange(0.8, 1.6);

      isChickMode = false;
      chickTimer = 0;
      isBikeMode = false;
      bikeTimer = 0;
      isStarMode = false;
      starTimer = 0;

      lives = 3;
      invincibleTimer = 0;

      jumpUsesLeft = 2;
      isCurrentlyThrusting = false;
      prevIsTouching = false;

      lostMessageTimer = 0;
      isRespawnPause = false;
      respawnPauseTimer = 0;

      lastDeathAvoidCenterX = null;
    }

    // ==========================
    // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    // ==========================
    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y
      );
    }

    function isPlayerOverHole(p) {
      const pxCenter = p.x + p.width / 2;
      for (const hole of holes) {
        if (pxCenter > hole.x && pxCenter < hole.x + hole.width) {
          return true;
        }
      }
      return false;
    }

    function getHoleCenterUnderX(centerX) {
      for (const hole of holes) {
        if (centerX > hole.x && centerX < hole.x + hole.width) {
          return hole.x + hole.width / 2;
        }
      }
      return null;
    }

    // æŒ‡å®šã—ãŸXï¼ˆä¸­å¿ƒï¼‰ãŒç©´ or æ•µ or ç›´å‰æ­»äº¡ãƒã‚¤ãƒ³ãƒˆã®è¿‘ãã‹ã©ã†ã‹
    function isCenterOverHoleOrEnemy(centerX) {
      // ç©´
      for (const hole of holes) {
        if (centerX > hole.x && centerX < hole.x + hole.width) {
          return true;
        }
      }
      // æ•µï¼ˆåœ°ä¸Šãƒ»ç©ºä¸­å«ã‚ï¼‰
      const enemyLists = [turtles, mushrooms, birds, bees, ghosts];
      const margin = 30; // å°‘ã—ã‚†ã¨ã‚Šã‚’æŒã£ã¦é¿ã‘ã‚‹
      for (const list of enemyLists) {
        for (const e of list) {
          const exCenter = e.x + e.width / 2;
          if (Math.abs(centerX - exCenter) < (e.width / 2 + margin)) {
            return true;
          }
        }
      }
      // ç›´å‰ã«æ­»ã‚“ã ä½ç½®ã®è¿‘ã
      const avoidMargin = 80;
      if (lastDeathAvoidCenterX != null) {
        if (Math.abs(centerX - lastDeathAvoidCenterX) < avoidMargin) {
          return true;
        }
      }
      return false;
    }

    // è½ä¸‹ãƒªã‚¹ãƒãƒ¼ãƒ³ç”¨ã®å®‰å…¨ãªXåº§æ¨™ã‚’æ¢ã™
    function findSafeRespawnX() {
      const minX = canvas.width * 0.10;
      const maxX = canvas.width * 0.30;
      const step = 20;

      // å€™è£œã‚’ãƒ©ãƒ³ãƒ€ãƒ é †ã«è©¦ã™
      const candidates = [];
      for (let x = minX; x <= maxX; x += step) {
        candidates.push(x);
      }
      for (let i = candidates.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
      }

      for (const x of candidates) {
        const cx = x + player.width / 2;
        if (!isCenterOverHoleOrEnemy(cx)) {
          return x;
        }
      }
      // è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°å…ƒã®åŸºæº–ä½ç½®
      return playerBaseX;
    }

    // ==========================
    // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
    // ==========================
    function activateChickMode() {
      isChickMode = true;
      chickTimer = CHICK_MODE_DURATION;
      if (isBikeMode) {
        isBikeMode = false;
        bikeTimer = 0;
      }
      player.emoji = "ğŸ¥";
      playChickSound();
    }

    function activateBikeMode() {
      isBikeMode = true;
      bikeTimer = BIKE_MODE_DURATION;
      if (isChickMode) {
        isChickMode = false;
        chickTimer = 0;
      }
      player.emoji = "ğŸš´";
      playBikeSound();
    }

    function activateStarMode() {
      isStarMode = true;
      starTimer = STAR_MODE_DURATION;
      playStarItemSound();
      // çµµæ–‡å­—ã¯ãã®ã¾ã¾ï¼ˆãƒ©ãƒ³ãƒ»ã²ã‚ˆã“ãƒ»è‡ªè»¢è»Šï¼‰ã§å‹•ä½œã ã‘ç„¡æ•µåŒ–ï¼‹é«˜é€Ÿå›è»¢
    }

    function updateModeTimers(dt) {
      if (isChickMode) {
        chickTimer -= dt;
        if (chickTimer <= 0) {
          isChickMode = false;
          chickTimer = 0;
          if (!isBikeMode) player.emoji = "ğŸƒâ€â™‚ï¸";
        }
      }
      if (isBikeMode) {
        bikeTimer -= dt;
        if (bikeTimer <= 0) {
          isBikeMode = false;
          bikeTimer = 0;
          if (!isChickMode) player.emoji = "ğŸƒâ€â™‚ï¸";
        }
      }
      if (isStarMode) {
        starTimer -= dt;
        if (starTimer <= 0) {
          isStarMode = false;
          starTimer = 0;
        }
      }
    }

    function getCurrentScrollSpeed() {
      if (isRespawnPause) return 0; // ãƒ­ã‚¹ãƒˆæ¼”å‡ºä¸­ã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åœæ­¢
      let speed = BASE_SCROLL_SPEED;
      if (isChickMode) speed = BASE_SCROLL_SPEED * 0.6;
      if (isBikeMode)  speed = BASE_SCROLL_SPEED * 1.3;
      // â­ãƒ¢ãƒ¼ãƒ‰ã¯ç§»å‹•é€Ÿåº¦ã¯å¤‰ãˆãšã€å›è»¢ã ã‘é€Ÿãã™ã‚‹
      return speed;
    }

    // ==========================
    // ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
    // ==========================
    function damagePlayer(options = {}) {
      if (invincibleTimer > 0 || gameOver) return;

      lives--;
      playHitSound();
      invincibleTimer = INVINCIBLE_TIME;
      lostMessageTimer = 1.0;

      if (lives <= 0) {
        gameOver = true;
        return;
      }

      if (options.respawnFromTop) {
        const groundY = getGroundY();

        // ç©´ï¼†æ•µï¼†ç›´å‰æ­»äº¡ä½ç½®ã‚’é¿ã‘ã‚‹å®‰å…¨ãªXã‚’æ¢ã—ã¦ãƒªã‚¹ãƒãƒ¼ãƒ³
        const safeX = findSafeRespawnX();
        player.x = safeX;
        playerBaseX = safeX;

        player.y = -player.height - 10;
        player.vy = 300;
        player.onGround = false;

        // ãƒ¢ãƒ¼ãƒ‰è§£é™¤
        isChickMode = false;
        chickTimer = 0;
        isBikeMode = false;
        bikeTimer = 0;
        isStarMode = false;
        starTimer = 0;
        player.emoji = "ğŸƒâ€â™‚ï¸";

        isRespawnPause = true;
        respawnPauseTimer = 1.2;
      }
    }

    // ==========================
    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆï¼ˆç¢ºç‡ã‚’ãƒ©ãƒ³ãƒ€ãƒ å¯„ã‚Šã«ï¼‰
    // ==========================
    function spawnObject() {
      const groundY = getGroundY();
      const x = canvas.width + 40;

      // åŒã˜ã‚«ãƒ†ã‚´ãƒªã‚’è¤‡æ•°å…¥ã‚Œã¦ã€Œãªã‚“ã¨ãªãå‡ºã‚„ã™ã„ï¼å‡ºã«ãã„ã€ã‚’è¡¨ç¾
      const categories = [
        "score", "score", "score",  // é£Ÿã¹ç‰©ã‚¢ã‚¤ãƒ†ãƒ å¤šã‚
        "chick",
        "bike",
        "wall",
        "stairs",
        "turtle",
        "mushroom",
        "platform",
        "air",
        "bee",
        "ghost",
        "hole", "hole",            // ç©´ã¯å°‘ã—å¤šã‚
        "star"                     // â­ã¯ãƒ¬ã‚¢
      ];

      const type = categories[Math.floor(Math.random() * categories.length)];

      if (type === "score") {
        const foodEmojis = ["ğŸ", "ğŸŒ", "ğŸ•", "ğŸ©", "ğŸ”", "ğŸ‡", "ğŸ°", "ğŸ–"];
        items.push({
          type: "score",
          x,
          y: randomRange(groundY * 0.3, groundY - 120),
          width: 28,
          height: 28,
          emoji: foodEmojis[Math.floor(Math.random() * foodEmojis.length)]
        });
      } else if (type === "chick") {
        items.push({
          type: "chick",
          x,
          y: randomRange(groundY * 0.3, groundY - 140),
          width: 30,
          height: 30,
          emoji: "ğŸ£"
        });
      } else if (type === "bike") {
        items.push({
          type: "bike",
          x,
          y: randomRange(groundY * 0.3, groundY - 140),
          width: 34,
          height: 34,
          emoji: "ğŸš²"
        });
      } else if (type === "wall") {
        const wallHeight = randomRange(50, 140);
        walls.push({
          x,
          y: groundY - wallHeight,
          width: 40,
          height: wallHeight
        });
      } else if (type === "stairs") {
        const stepCount = Math.random() < 0.5 ? 2 : 3;
        const stepWidth = 40;
        const stepHeight = 35;
        for (let i = 0; i < stepCount; i++) {
          const h = stepHeight * (i + 1);
          walls.push({
            x: x + i * stepWidth,
            y: groundY - h,
            width: stepWidth,
            height: h
          });
        }
      } else if (type === "turtle") {
        const h = 32;
        turtles.push({
          x,
          y: groundY - h,
          width: 40,
          height: h,
          emoji: "ğŸ¢"
        });
      } else if (type === "mushroom") {
        const h = 32;
        mushrooms.push({
          x,
          y: groundY - h,
          width: 32,
          height: h,
          emoji: "ğŸ„"
        });
      } else if (type === "platform") {
        // ç©ºä¸­ã«æµ®ã„ã¦å‹•ã„ã¦ãã‚‹åºŠ
        const platWidth = randomRange(80, 140);
        const platHeight = 16;
        const baseY = randomRange(groundY * 0.35, groundY * 0.6);
        platforms.push({
          x,
          y: baseY,
          baseY,
          width: platWidth,
          height: platHeight,
          amp: randomRange(20, 40),
          omega: randomRange(1.0, 2.0),
          phase: Math.random() * Math.PI * 2,
          isMoving: true
        });
      } else if (type === "air") {
        const h = 32;
        const airEmojis = ["ğŸ¦", "ğŸ’£", "ğŸŒ¶ï¸"];
        birds.push({
          x,
          y: randomRange(80, groundY - 130),
          width: 40,
          height: h,
          emoji: airEmojis[Math.floor(Math.random() * airEmojis.length)]
        });
      } else if (type === "bee") {
        const baseY = randomRange(80, groundY - 140);
        const amp = randomRange(20, 50);
        const omega = randomRange(2, 4);
        bees.push({
          x,
          baseY,
          y: baseY,
          width: 40,
          height: 32,
          emoji: "ğŸ",
          phase: Math.random() * Math.PI * 2,
          amp,
          omega
        });
      } else if (type === "ghost") {
        const baseY = randomRange(80, groundY - 130);
        ghosts.push({
          x,
          baseY,
          y: baseY,
          width: 40,
          height: 32,
          emoji: "ğŸ‘»",
          phase: Math.random() * Math.PI * 2,
          moveState: 1,                     // 1:å‹•ã, 0:æ­¢ã¾ã‚‹
          moveTimer: randomRange(0.3, 0.8)
        });
      } else if (type === "hole") {
        const holeWidth = randomRange(80, 140);
        holes.push({
          x,
          width: holeWidth
        });
      } else if (type === "star") {
        items.push({
          type: "star",
          x,
          y: randomRange(groundY * 0.25, groundY - 160),
          width: 30,
          height: 30,
          emoji: "â­"
        });
      }
    }

    // ==========================
    // å…¥åŠ›ï¼ˆã‚¿ãƒƒãƒ—ãƒ»ã‚¹ãƒ¯ã‚¤ãƒ—ï¼‰
    // ==========================
    function handleTouchStart(e) {
      e.preventDefault();

      if (!audioCtx) {
        initAudio();
      } else {
        resumeAudio();
      }

      if (gameOver) {
        resetGame();
      }
      isTouching = true;

      const t = e.touches[0];
      touchStartY = t.clientY;
    }

    function handleTouchEnd(e) {
      e.preventDefault();
      isTouching = false;
      touchStartY = null;
    }

    function handleTouchMove(e) {
      e.preventDefault();
      if (e.touches.length === 0) return;
      const t = e.touches[0];
      if (touchStartY === null) touchStartY = t.clientY;
      const dy = t.clientY - touchStartY;

      // ä¸‹ã‚¹ãƒ¯ã‚¤ãƒ—ã§é«˜é€Ÿè½ä¸‹
      if (dy > 40 && !player.onGround && !gameOver) {
        isTouching = false;
        isCurrentlyThrusting = false;
        jumpUsesLeft = 0;
        if (player.vy < 900) player.vy = 900;
      }
    }

    function setupInput() {
      canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
      canvas.addEventListener("touchend", handleTouchEnd, { passive: false });
      canvas.addEventListener("touchmove", handleTouchMove, { passive: false });

      document.addEventListener("touchmove", function (e) {
        e.preventDefault();
      }, { passive: false });

      // PCãƒ†ã‚¹ãƒˆç”¨
      canvas.addEventListener("mousedown", (e) => {
        e.preventDefault();
        if (!audioCtx) {
          initAudio();
        } else {
          resumeAudio();
        }
        if (gameOver) {
          resetGame();
        }
        isTouching = true;
      });
      canvas.addEventListener("mouseup", (e) => {
        e.preventDefault();
        isTouching = false;
      });
      canvas.addEventListener("mouseleave", () => {
        isTouching = false;
      });
    }

    // ==========================
    // ã‚²ãƒ¼ãƒ æ›´æ–°
    // ==========================
    function update(dt) {
      if (gameOver) return;

      const groundY = getGroundY();

      // ã‚¿ã‚¤ãƒãƒ¼é¡
      if (invincibleTimer > 0) {
        invincibleTimer -= dt;
        if (invincibleTimer < 0) invincibleTimer = 0;
      }
      if (lostMessageTimer > 0) {
        lostMessageTimer -= dt;
        if (lostMessageTimer < 0) lostMessageTimer = 0;
      }
      if (isRespawnPause) {
        respawnPauseTimer -= dt;
        if (respawnPauseTimer < 0) respawnPauseTimer = 0;
      }

      updateModeTimers(dt);

      const scrollSpeed = getCurrentScrollSpeed();
      const scroll = scrollSpeed * dt;

      // ã‚¿ãƒƒãƒ—ã®ON/OFFã§ã‚¸ãƒ£ãƒ³ãƒ—å›æ•°ç®¡ç†
      if (!isTouching && prevIsTouching) {
        if (isCurrentlyThrusting) {
          jumpUsesLeft = Math.max(0, jumpUsesLeft - 1);
          isCurrentlyThrusting = false;
        }
      }

      if (isTouching && !gameOver && !isRespawnPause) {
        if (!isCurrentlyThrusting && jumpUsesLeft > 0) {
          isCurrentlyThrusting = true;
        }
      }

      if (isCurrentlyThrusting) {
        player.vy = -300;
      } else {
        player.vy += GRAVITY * dt;
      }

      const prevY = player.y;
      player.y += player.vy * dt;

      // ä¸Šé™ï¼†å¼·åˆ¶è½ä¸‹é–‹å§‹
      if (player.y < TOP_LIMIT) {
        player.y = TOP_LIMIT;
        if (player.vy < 0) player.vy = 0;
        if (isCurrentlyThrusting) {
          isCurrentlyThrusting = false;
          jumpUsesLeft = Math.max(0, jumpUsesLeft - 1);
        }
      }

      let playerBottom = player.y + player.height;
      let playerTop = player.y;

      // è¶³å ´ï¼ˆå£ï¼‹ç©ºä¸­åºŠï¼‰ï¼šç¸¦æ–¹å‘
      const solids = platforms.concat(walls);
      let onPlatform = false;

      for (const solid of solids) {
        const overlapX =
          player.x + player.width > solid.x &&
          player.x < solid.x + solid.width;
        if (!overlapX) continue;

        // ä¸Šã‹ã‚‰ç€åœ°
        if (
          player.vy >= 0 &&
          playerBottom >= solid.y &&
          playerBottom <= solid.y + solid.height
        ) {
          player.y = solid.y - player.height;
          player.vy = 0;
          playerBottom = player.y + player.height;
          playerTop = player.y;
          onPlatform = true;
          break;
        }

        // ä¸‹ã‹ã‚‰ã¶ã¤ã‹ã£ãŸã‚‰ä¸Šã«æŠœã‘ãªã„
        if (
          player.vy < 0 &&
          playerTop <= solid.y + solid.height &&
          prevY >= solid.y + solid.height
        ) {
          player.y = solid.y + solid.height;
          player.vy = 0;
          playerTop = player.y;
          playerBottom = player.y + player.height;
          break;
        }
      }

      // åœ°é¢ãƒ»ç©´ï¼šç©´ã®ä¸Šãªã‚‰è½ã¡ç¶šã‘ã‚‹ã€ãã†ã§ãªã‘ã‚Œã°åœ°é¢ã§æ­¢ã¾ã‚‹
      let onGroundNow = false;
      if (!onPlatform && player.vy >= 0 && playerBottom >= groundY) {
        if (!isPlayerOverHole(player)) {
          player.y = groundY - player.height;
          player.vy = 0;
          playerBottom = player.y + player.height;
          playerTop = player.y;
          onGroundNow = true;
        }
        // ç©´ã®ä¸Šã®ã¨ãã¯ãã®ã¾ã¾ä¸‹ã«è½ã¡ã‚‹ â†’ ç”»é¢å¤–ã§ãƒ­ã‚¹ãƒˆå‡¦ç†ã¸
      }

      player.onGround = onGroundNow || onPlatform;

      // ç”»é¢ä¸‹ã¾ã§è½ã¡ãŸã‚‰ãƒ­ã‚¹ãƒˆï¼ˆç©´ã‚„å´–è½ã¡ï¼‰
      if (player.y > canvas.height && invincibleTimer <= 0) {
        const centerX = player.x + player.width / 2;
        const holeCenter = getHoleCenterUnderX(centerX);
        if (holeCenter != null) {
          lastDeathAvoidCenterX = holeCenter;
        } else {
          lastDeathAvoidCenterX = centerX; // è½ã¡åœ°ç‚¹ãã®ã‚‚ã®ã‚’é¿ã‘å¯¾è±¡ã«
        }
        damagePlayer({ respawnFromTop: true });
      }

      // è¶³å ´ã«ç«‹ã£ã¦ã„ã‚‹ã¨ãã¯ã‚¸ãƒ£ãƒ³ãƒ—å›æ•°ãƒªã‚»ãƒƒãƒˆ
      if (player.onGround && player.vy === 0) {
        jumpUsesLeft = 2;
        if (!isTouching) {
          isCurrentlyThrusting = false;
        }
      }

      // èƒŒæ™¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç§»å‹•
      function moveAndFilter(list) {
        return list
          .map(obj => {
            obj.x -= scroll;
            return obj;
          })
          .filter(obj => obj.x + (obj.width || 0) > -50);
      }

      walls = moveAndFilter(walls);
      platforms = moveAndFilter(platforms);
      items = moveAndFilter(items);
      birds = moveAndFilter(birds);
      turtles = moveAndFilter(turtles);
      mushrooms = moveAndFilter(mushrooms);

      holes = holes
        .map(hole => {
          hole.x -= scroll;
          return hole;
        })
        .filter(hole => hole.x + hole.width > -50);

      // å‹•ãç©ºä¸­åºŠï¼šä¸Šä¸‹ãµã‚ãµã‚
      for (const plat of platforms) {
        if (plat.isMoving) {
          plat.phase += plat.omega * dt;
          plat.y = plat.baseY + plat.amp * Math.sin(plat.phase);
        }
      }

      // èœ‚ï¼šæ¨ªã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã€ç¸¦ã¯ã‚µã‚¤ãƒ³ã‚«ãƒ¼ãƒ–
      bees = moveAndFilter(bees);
      for (const bee of bees) {
        bee.phase += bee.omega * dt;
        bee.y = bee.baseY + bee.amp * Math.sin(bee.phase);
      }

      // ã‚ªãƒã‚±ï¼šé€²ã‚“ã ã‚Šæ­¢ã¾ã£ãŸã‚Šï¼‹ä¸Šä¸‹ãµã‚ãµã‚
      ghosts = ghosts.filter(g => {
        if (g.moveState === 1) {
          g.x -= scroll;
        }
        g.moveTimer -= dt;
        if (g.moveTimer <= 0) {
          g.moveState = g.moveState === 1 ? 0 : 1;
          g.moveTimer = randomRange(0.3, 0.8);
        }
        g.phase += 1.5 * dt;
        g.y = g.baseY + 10 * Math.sin(g.phase);
        return g.x + g.width > -50;
      });

      // å£ã®æ¨ªè¡çªï¼šæŠ¼ã—æˆ»ã™
      let playerRect = {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      };

      let pushedByWall = false;
      for (const wall of walls) {
        const wallRect = {
          x: wall.x,
          y: wall.y,
          width: wall.width,
          height: wall.height
        };
        if (rectsOverlap(playerRect, wallRect)) {
          player.x = wall.x - player.width;
          playerRect.x = player.x;
          pushedByWall = true;
        }
      }

      // å£ã«æŠ¼ã—å‡ºã•ã‚Œã¦ç”»é¢å¤– â†’ ãƒ­ã‚¹ãƒˆï¼‹ä¸Šã‹ã‚‰æ–°ã—ã„è‡ªåˆ†
      if (player.x + player.width < 0 && invincibleTimer <= 0) {
        lastDeathAvoidCenterX = player.x + player.width / 2;
        damagePlayer({ respawnFromTop: true });
        playerRect.x = player.x;
        playerRect.y = player.y;
      }

      // å£ã‚’æŠœã‘ãŸã‚‰åŸºæº–ä½ç½®ã«æˆ»ã‚‹
      if (!pushedByWall && player.x < playerBaseX && !isRespawnPause) {
        const returnSpeed = 300;
        player.x += returnSpeed * dt;
        if (player.x > playerBaseX) player.x = playerBaseX;
        playerRect.x = player.x;
      }

      // æ•µã¨ã®å½“ãŸã‚Šåˆ¤å®š
      function handleEnemyHit(list, index, centerX) {
        // ç›´å‰ã«ã‚„ã‚‰ã‚ŒãŸä½ç½®ã‚’è¨˜éŒ²ï¼ˆåŒã˜ã®ã‚’é¿ã‘ã‚‹ï¼‰
        lastDeathAvoidCenterX = centerX;

        // â­ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯æ•µã‚’å€’ã—ã¦åŠ ç‚¹ãƒ»ãƒ­ã‚¹ãƒˆã—ãªã„
        if (isStarMode) {
          const enemy = list[index];
          if (enemy) {
            score += 30;
            playStarHitSound();
            floatTexts.push({
              x: enemy.x + enemy.width / 2,
              y: enemy.y,
              text: "+30",
              life: 0.8
            });
          }
          list.splice(index, 1); // æ•µã‚’æ¶ˆã™
          return;
        }

        // è‡ªè»¢è»Šãƒ¢ãƒ¼ãƒ‰ï¼šä¸€å›ã ã‘èº«ä»£ã‚ã‚Šçš„ã«è§£é™¤
        if (isBikeMode) {
          isBikeMode = false;
          bikeTimer = 0;
          if (!isChickMode) player.emoji = "ğŸƒâ€â™‚ï¸";
        } else if (invincibleTimer <= 0) {
          damagePlayer({ respawnFromTop: true });
        }
      }

      // äº€
      for (let i = 0; i < turtles.length && !gameOver; i++) {
        if (rectsOverlap(playerRect, turtles[i])) {
          const c = turtles[i].x + turtles[i].width / 2;
          handleEnemyHit(turtles, i, c);
          break;
        }
      }
      // ã‚­ãƒã‚³
      for (let i = 0; i < mushrooms.length && !gameOver; i++) {
        if (rectsOverlap(playerRect, mushrooms[i])) {
          const c = mushrooms[i].x + mushrooms[i].width / 2;
          handleEnemyHit(mushrooms, i, c);
          break;
        }
      }
      // é³¥ãƒ»çˆ†å¼¾ãƒ»å”è¾›å­
      for (let i = 0; i < birds.length && !gameOver; i++) {
        if (rectsOverlap(playerRect, birds[i])) {
          const c = birds[i].x + birds[i].width / 2;
          handleEnemyHit(birds, i, c);
          break;
        }
      }
      // èœ‚
      for (let i = 0; i < bees.length && !gameOver; i++) {
        const bee = bees[i];
        const beeRect = {
          x: bee.x,
          y: bee.y,
          width: bee.width,
          height: bee.height
        };
        if (rectsOverlap(playerRect, beeRect)) {
          const c = bee.x + bee.width / 2;
          handleEnemyHit(bees, i, c);
          break;
        }
      }
      // ã‚ªãƒã‚±
      for (let i = 0; i < ghosts.length && !gameOver; i++) {
        const g = ghosts[i];
        const gRect = {
          x: g.x,
          y: g.y,
          width: g.width,
          height: g.height
        };
        if (rectsOverlap(playerRect, gRect)) {
          const c = g.x + g.width / 2;
          handleEnemyHit(ghosts, i, c);
          break;
        }
      }

      // ã‚¢ã‚¤ãƒ†ãƒ å–å¾—
      if (!gameOver) {
        items = items.filter(item => {
          if (rectsOverlap(playerRect, item)) {
            let text = "";
            if (item.type === "score") {
              score += 10;
              playScoreItemSound();
              text = "+10";
            } else if (item.type === "chick") {
              activateChickMode();
              text = "ğŸ¥";
            } else if (item.type === "bike") {
              const wasBike = isBikeMode;
              if (wasBike) {
                score += 20;
                playBikeBonusSound();
                text = "+20";
              } else {
                text = "ğŸš´";
              }
              activateBikeMode();
            } else if (item.type === "star") {
              activateStarMode();
              text = "â­";
            }
            floatTexts.push({
              x: item.x + item.width / 2,
              y: item.y,
              text,
              life: 0.8
            });
            return false;
          }
          return true;
        });
      }

      // ã‚¹ã‚³ã‚¢ï¼ˆç”Ÿå­˜æ™‚é–“ï¼‰â€»ãƒ­ã‚¹ãƒˆæ¼”å‡ºä¸­ã¯å¢—ãˆãªã„
      if (!gameOver && !isRespawnPause) {
        score += dt * 5;
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢ï¼ˆå‰è»¢ï¼‰
      const inNormalMode = !isBikeMode && !isChickMode;
      let rollDir = 1;
      if (isBikeMode || inNormalMode || isStarMode) {
        // å³å‘ãæç”»ãªã®ã§ç¬¦å·åè»¢ã§å‰è»¢ã«è¦‹ã›ã‚‹
        rollDir = -1;
      }
      let rollSpeed = 4.0;
      if (isStarMode) {
        rollSpeed = 10.0; // â­ä¸­ã¯é«˜é€Ÿãƒãƒƒã‚¯ãƒ•ãƒªãƒƒãƒ—
      }
      player.angle += rollDir * rollSpeed * dt;

      // ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆ
      floatTexts = floatTexts.filter(ft => {
        ft.y -= 40 * dt;
        ft.life -= dt;
        return ft.life > 0;
      });

      // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆï¼ˆãƒ­ã‚¹ãƒˆä¸€æ™‚åœæ­¢ä¸­ã¯ç”Ÿæˆã—ãªã„ï¼‰
      if (!isRespawnPause) {
        spawnTimer += dt;
        if (spawnTimer >= nextSpawnTime) {
          spawnObject();
          spawnTimer = 0;
          nextSpawnTime = randomRange(0.8, 1.6);
        }
      }

      // ãƒªã‚¹ãƒãƒ¼ãƒ³ä¸€æ™‚åœæ­¢è§£é™¤ï¼š
      if (isRespawnPause && respawnPauseTimer <= 0 && player.onGround) {
        isRespawnPause = false;
      }

      prevIsTouching = isTouching;
    }

    // ==========================
    // æç”»
    // ==========================
    function draw() {
      const groundY = getGroundY();

      // èƒŒæ™¯
      ctx.fillStyle = "#87ceeb";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // åœ°é¢
      ctx.fillStyle = "#3c7c1b";
      ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

      // ç©´ï¼ˆåœ°é¢ã‚’ãã‚ŠæŠœãï¼‰
      ctx.fillStyle = "#87ceeb";
      for (const hole of holes) {
        ctx.fillRect(hole.x, groundY, hole.width, canvas.height - groundY);
      }

      // å£
      ctx.fillStyle = "#8b4513";
      for (const wall of walls) {
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      }

      // ç©ºä¸­åºŠ
      ctx.fillStyle = "#cccccc";
      for (const plat of platforms) {
        ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
      const cx = player.x + player.width / 2;
      const cy = player.y + player.height / 2;
      ctx.save();
      ctx.translate(cx, cy);

      const inNormalMode = !isBikeMode && !isChickMode;
      if (isBikeMode || inNormalMode || isStarMode) {
        ctx.scale(-1, 1);
      }

      ctx.rotate(player.angle);
      ctx.font = "32px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(player.emoji, 0, 0);
      ctx.restore();

      // æ•µãƒ»ç©ºä¸­æ•µãƒ»ã‚¢ã‚¤ãƒ†ãƒ 
      ctx.font = "28px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (const t of turtles) {
        ctx.fillText(t.emoji, t.x + t.width / 2, t.y + t.height / 2);
      }
      for (const m of mushrooms) {
        ctx.fillText(m.emoji, m.x + m.width / 2, m.y + m.height / 2);
      }
      for (const b of birds) {
        ctx.fillText(b.emoji, b.x + b.width / 2, b.y + b.height / 2);
      }
      for (const bee of bees) {
        ctx.fillText(bee.emoji, bee.x + bee.width / 2, bee.y + bee.height / 2);
      }
      for (const g of ghosts) {
        ctx.fillText(g.emoji, g.x + g.width / 2, g.y + g.height / 2);
      }
      for (const item of items) {
        ctx.fillText(item.emoji, item.x + item.width / 2, item.y + item.height / 2);
      }

      // ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆ
      for (const ft of floatTexts) {
        const alpha = Math.max(0, ft.life / 0.8);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "#ffff00";
        ctx.font = "18px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.restore();
      }

      // ãƒ©ã‚¤ãƒ•
      ctx.fillStyle = "#ff0000";
      ctx.font = "24px system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("â¤ï¸".repeat(lives), 10, 10);

      // ã‚¹ã‚³ã‚¢
      ctx.fillStyle = "#000000";
      ctx.font = "20px system-ui";
      ctx.textAlign = "right";
      ctx.textBaseline = "top";
      ctx.fillText("Score: " + Math.floor(score), canvas.width - 16, 10);

      // LOST è¡¨ç¤º
      if (lostMessageTimer > 0 && !gameOver) {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#ff4444";
        ctx.font = "32px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("LOST!", canvas.width / 2, canvas.height / 2);
        ctx.restore();
      }

      // Game Over
      if (gameOver) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        ctx.font = "36px system-ui";
        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 20);

        ctx.font = "24px system-ui";
        ctx.fillText("Score: " + Math.floor(score), canvas.width / 2, canvas.height / 2 + 20);

        ctx.font = "18px system-ui";
        ctx.fillText("ç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ", canvas.width / 2, canvas.height / 2 + 60);
      }
    }

    // ==========================
    // ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
    // ==========================
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    // ==========================
    // åˆæœŸåŒ–
    // ==========================
    function init() {
      resizeCanvas();
      resetGame();
      setupInput();
      requestAnimationFrame(gameLoop);
    }

    window.addEventListener("resize", () => {
      resizeCanvas();
      resetGame();
    });

    init();
  </script>
</body>
</html>
